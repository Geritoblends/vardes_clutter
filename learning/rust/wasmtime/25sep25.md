# Plugin system using wasmtime::Caller


### Part I. Methods

#### 1. Define the Host Data struct
```rust
use wasmtime::Func;

struct HostData {
    methods: HashMap<String, Func>, // String should be changed to a fixed-length variable
    listeners: HashMap<String, Vec<Func>> // Same thing
}
```

#### 2. Get some module's Func exports

```rust
for export in instance.exports(&mut store) {
    if let Some(func) = export.into_func() {
        let name = export.name().to_string();
        &self.methods.insert(name, func);
    }
}
```

#### 3. Create a Host function that will be imported to all the Modules

`wasmtime::Caller` allows us to have both, the Calling (the Module that calls the function) and Host state from the Module's perspective:

```rust
fn host_function(
    mut caller: Caller<'_, HostData>, 
    args_ptr: i32, 
    args_len: i32, 
    fn_name_ptr: i32,
    fn_name_len: i32
) -> i32 {
    // Get the calling module's memory
    let memory = caller.get_export("memory")
        .and_then(|e| e.into_memory())
        .unwrap();
    
    // Read the function name from the caller's memory
    let memory_data = memory.data(&caller);
    let fn_name_bytes = &memory_data[fn_name_ptr as usize..(fn_name_ptr + fn_name_len) as usize];
    let fn_name = std::str::from_utf8(fn_name_bytes).unwrap();
    
    // Read the arguments from the caller's memory
    let args_bytes = &memory_data[args_ptr as usize..(args_ptr + args_len) as usize];
    
    // Get the function from host data
    let host_data = caller.data();
    let other_func = match host_data.global_functions.get(fn_name) {
        Some(func) => func,
        None => {
            // Function not found - could write error to memory or return error code
            return -1;
        }
    };
    
    // Convert args_bytes to WebAssembly values
    // This depends on your serialization format - example with simple i32 args:
    let wasm_args: Vec<wasmtime::Val> = args_bytes
        .chunks_exact(4)
        .map(|chunk| {
            let value = i32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]);
            wasmtime::Val::I32(value)
        })
        .collect();
    
    // Call the function
    let mut results = vec![wasmtime::Val::I32(0); other_func.ty(&caller).results().len()];
    match other_func.call(&mut caller, &wasm_args, &mut results) {
        Ok(()) => {
            // Write results back to caller's memory
            let memory_data_mut = memory.data_mut(&mut caller);
            
            // Write results starting at args_ptr (overwriting input)
            // Or you could use a different location
            let mut offset = args_ptr as usize;
            for result in results {
                match result {
                    wasmtime::Val::I32(val) => {
                        let bytes = val.to_le_bytes();
                        memory_data_mut[offset..offset + 4].copy_from_slice(&bytes);
                        offset += 4;
                    }
                    wasmtime::Val::I64(val) => {
                        let bytes = val.to_le_bytes();
                        memory_data_mut[offset..offset + 8].copy_from_slice(&bytes);
                        offset += 8;
                    }
                    // Handle other types as needed...
                    _ => {}
                }
            }
            
            0 // Success
        }
        Err(_) => -2 // Function call failed
    }
}
```
