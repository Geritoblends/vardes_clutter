# Host-side vs shared Memory function registry in WASM modules

#### Host-side

**Benefits**
* Can't be tampered by a malicious plugin

**How**
```rust
// Iterate through exports more directly
for (name, export) in instance.exports(&mut store) {
    if let Some(func) = export.into_func() {
        println!("Function export '{}' found", name);
        // You can now use `func`
    }
}
```

```rust
let mut function_registry: HashMap<String, u32> = HashMap::new();
let mut table_index = 0;
    
// Iterate through function exports and add them to the table
for (name, export) in instance.exports(&mut store) {
    if let Some(func) = export.into_func() {
        println!("Adding function '{}' to table at index {}", name, table_index);

        // Store the function in the table
        table.set(&mut store, table_index, Val::FuncRef(Some(func)))?;

        function_registry.insert(name.to_string(), table_index); // then import a host function get_fn_id_from_name(ptr, len) -> i32;

        table_index += 1;
    }
}
```

#### shared Memory

**Benefits**
* Less lag? (doesn't apply, function lookup is a one-time thing)


