# Client network-to-side_effect logic

#### General
In order to be able to plug arbitrary plugins to the client Wireplumber, we need a general interface for them.
The approach that allows us no allocation per message emitted is this:

##### Wireplumber
```rust
pub struct Wireplumber {
    plugins: ArcSwap<HashMap<[u8; 12], Box<dyn Plugin>>>
}
```

Wireplumber will hot-swap Plugins and execute them perhaps asynchronously (hence the ArcSwap wrapper)

##### Plugin interface
```rust
pub trait Plugin {
    fn copy_msg(data: *const u8, len: usize);
}
```

Plugins will know the exact length of the Message they receive, hence N is known at compile-time:

```rust
pub struct Message<const N: usize> {
    len: usize,
    payload: [u8; N]
}
```

They'll be able to copy the bytes from the *const u8 to their fixed-size payload, and then they'll stop needing the reference, and will be able to run a separate thread with full message ownership.


#### Plugins calling plugins

In order to be able to have modular systems work meaningfully with each other, we'd need the WASM/dynlib SideEffects to talk directly to Cores, for example, if we have a custom InventoryManagementSideEffect, that receives messages from the core netcode, and wants to update the GodotGUICore or GodotLocalStore, we'll need a way to send messages/commands from the side effect to that Core. 
The solution is: we'll simply use FFI as we normally do from the core WirePlumber to the plugins. Cores will expose C ABI-compatible methods that SideEffects will plug to.
