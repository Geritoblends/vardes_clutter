# Client-side core engine decisions and its implications

#### General
As i've previously mentioned, the core client-side engine will be a plugin system where plugins are either hot-swappable dynamic libraries or WASM modules.


#### **Dynamic libraries**
They're bundled with the client binary, and loaded whenever they're needed. This allows us to have a huge amount of trusted plugins with perfect performance and permissions

**Tradeoff**
If we only used bundled plugins, ecosystem growth would depend solely on the project repository, creating a huge single point of contention.

**Things I currently have no idea on how to implement**
To have something like
```rust
pub struct ClientEngine {
    plugins: ArcSwap<HashMap<[u8; 12], Plugin>>,
}
```
without performance overhead of looking up the function symbol each time, we need to handle the lifetime of the Symbol and place it directly as a Plugin property OR as claude suggested, use the raw function pointer as the property `call_copy_msg`.

```rust
// Claude's suggestion
pub struct Plugin { 
    _library: libloading::Library,
    call_copy_msg: *


#### **WASM modules**
It's possible to download them and run them dynamically at runtime even in iOS, and they're inherently sandboxed, so they're perfect for having secure community-made plugins. With them, ecosystem growth will be much faster, so they're essential.

**Tradeoffs**
They only run synchronously, hence our logic about "copy_msg, then spawn a task with the owned message" won't work and needs a full rethink.
We'll likely end up directly copying the message payload bytes to the module's linear memory and calling the module's function as the u32 pointer and u32 len
